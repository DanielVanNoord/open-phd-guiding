#summary Unified cross-platform CMake build system
#sidebar

*Work in progress*

<wiki:toc max_depth="3" />

[http://www.cmake.org CMake] is a cross-platform meta-build system. The tool translates the rules for building, checking and installing the !OpenPhdGuiding project, written in the cmake language, 
into rules specific to your development environment and platform. The same script is used for creating Visual Studio or XCode project, or Makefile. 
The advantages of cmake are many, among which one can cite:
  * the maintenance of only one language for addressing the build of !OpenPhdGuiding on all platforms
  * the possibility to manage big projects and complex dependencies
  * the possibility to add unit tests and installation procedures

This page describes the steps to configure the !OpenPhdGuiding for your specific platform, as well as some hints and best practices for new `cmake` developers. 
If you need more information about CMake, you may first consult the CMake documentation online. Also, a lot of resources are available on the Internet. 

= Introduction =
The full build of the project in made in three steps
  # build and/or install the dependencies
  # configure cmake
  # build the project


= Preliminary notes =

== Checking out the code ==
The code is hosted on an SVN server located here: http://open-phd-guiding.googlecode.com/svn/. 
The branch that supports the cmake configuration is named *`new_build_system`*. The checkout command is then the following

{{{
svn checkout http://open-phd-guiding.googlecode.com/svn/branches/new_build_system open-phd-guiding
}}}

For that to work, you need an SVN client:

  * On Debian/Ubuntu, the installation would be
    {{{
    sudo apt-get install build-essential subversion
    }}}
  * On OSX, the svn client should be shipped with the OS (accessible from the terminal), 
  * and on Windows, there is TortoiseSVN that can be installed

From now on, we suppose the code has been checked out in *`$OPG_SRC`* (the `open-phd-guiding` path above).

== Development environments ==
The following development environment have been tested with the current `cmake` build system:
  * Windows: Visual Studio 2013 Express Edition
  * OSX: XCode 5, clang 5, and make
  * Linux: gcc4.6, make

== Supported architectures ==
Currently on Windows and OSX, the supported architecture is 32 bits only. This is because of the external libraries used in the project for driving specific astronomy hardware. Most of this specificity
is handled in the cmake script. However, the wxWidgets should be built accordingly. 

== Visual Studio versions ==
We suppose _Visual Studio 2013_ installed for Windows developers. The code name in _cmake_ for this version of Visual Studio is _Visual Studio 12_ ("12" stands for the version, which is _Visual Studio 2013_). 

== XCode versions ===
We suppose XCode 5 installed for Mac OSX developers. XCode 5 comes with _clang_ C++ compiler, which makes the compilation of _wxWidgets_ slightly more difficult than usual. 


= Project dependencies =
The cmake construction of !OpenPhdGuiding depends only on these external dependencies
  * CMake
  * wxWidget on all platforms
  * openCV on Windows
  * The [http://www.indilib.org/ Indi] and [http://libnova.sourceforge.net/ Nova] library packages on Ubuntu


This means that these dependencies should be available in order to be able to construct the project, and `cmake` should know where to find these dependencies. 
!OpenPhdGuiding has in fact many more dependencies, but they are shipped with the project and built within the project automatically (or chosen from the 
system wide installed libraries). These dependencies are:
  * openSSAG
  * libdc
  * libusb
  * cfitsio
  * and many more


== Installing CMake ==
[http://www.cmake.org CMake] provides binary installers for Windows and OSX. On Linux, you should be able to install `cmake` via the package manager
{{{
sudo apt-get install cmake
}}}

== Building and installing wxWidgets ==
We assume 
  * `$WXWIDGET_BASE_DIR` being a variable that points to the untarred sources of _wxWidgets_.
  * `$WXWIN` being a variable that points to the installation prefix of your dependencies.

=== Win32 ===
Open a Visual Studio console and type the following commands, respectively for the Debug and Release versions of the libraries.
{{{
cd $WXWIDGET_BASE_DIR\build\msw
msbuild wx_vc12.sln /p:configuration=Debug /p:platform=win32 /m:8
msbuild wx_vc12.sln /p:configuration=Release /p:platform=win32 /m:8
}}}

The `wx_vc12.sln` Visual Studio solution is for Visual Studio 12 (Visual 2013, see [#Visual_Studio_versions here]). 

=== OSX ===
The configuration on OSX looks a little bit complicated. We are using XCode 5 and above, which is shipped with Clang 3+.
{{{
cd $WXWIDGET_BASE_DIR
../configure --enable-universal_binary=i386,x86_64 --disable-shared --with-libpng=builtin --with-cocoa --prefix=$WXWIN \
             --with-macosx-sdk=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/ \
             --with-macosx-version-min=10.7 \
             CXXFLAGS="-stdlib=libc++ -std=c++11" \
             OBJCXXFLAGS="-stdlib=libc++ -std=c++11" \
             CPPFLAGS="-stdlib=libc++"  \
             LDFLAGS="-stdlib=libc++" CXX=clang++ CXXCPP="clang++ -E" CC=clang CPP="clang -E"
make
make install
}}}

=== Linux ===
Under Linux, the wxWidget should be available through the package manager. You need the _developer_ package using GTK:
{{{
sudo apt-get install libwxgtk3.0-dev wx-common wx3.0-i18n
}}}


== Installing Indi and Nova ==
On Linux, the [http://www.indilib.org/ Indi] and [http://libnova.sourceforge.net/ Nova] library packages should be available for the project. 
Simply run the following command to install the development version of these packages, as follows:

{{{
sudo apt-get install libindi-dev libnova-dev
}}}

The `cmake` configuration should find these packages. It is required to have libindi-dev >= 0.9. 

== Building and installing OpenCV ==
We recall that the dependency on openCV is needed on Win32 platforms only. Nothing really needs to be built since the OpenCV
zip contains libraries already built for Windows, and also certainly for your platform. Just download OpenCV from [http://www.opencv.org the official website]
or [http://sourceforge.net/projects/opencvlibrary/ SourceForge].

We assume `$OPENCV_DIR` being a variable that points to the location where OpenCV was deflated. 

= Configuring the !OpenPhdGuiding project =
Once the dependencies available on your system, you are able to build the project. For that, you should inform the location of these dependencies to cmake, passed as options to cmake.
The basic scheme is
  # open a terminal. Under Windows, the terminal should be the one provided by the Visual Studio command line tool, which has the proper environment variables defining the compiler and the SDKs
  # go to the source directory *`$OPG_SRC`* and create a subdirectory where the project will be built
  # type the `cmake` command line with the proper options
  # open the generated project or make the project in place

== Creating the Visual Studio project ==
We suppose you have 
  * CMake
  * Visual Studio 12 installed (see [#Visual_Studio_versions here] for more details)
  * build properly [#Building_and_installing_wxWidgets  wxWidgets] and [#Building_and_installing_OpenCV OpenCV]

{{{
cd $OPG_SRC
mkdir tmp
cd tmp
cmake -G "Visual Studio 12" -DwxWidgets_ROOT_DIR=$WXWIN -DOpenCVRoot=$OPENCV_DIR\opencv\build ..
PhD2.sln
}}}

The last line opens the solution in Visual Studio.

== Creating the XCode project on OSX ==
We suppose you have 
  * CMake
  * XCode installed
  * build properly [#Building_and_installing_wxWidgets  wxWidgets]

To construct the XCode project, follow the instructions below. Note that the project is built with 32 bits architecture,
as some dependencies are not available for 64 bits architecture. 
{{{
cd $OPG_SRC
mkdir tmp
cd tmp
cmake -G Xcode -DwxWidgets_PREFIX_DIRECTORY=$WXWIN -DCMAKE_OSX_ARCHITECTURES=i386 -DCMAKE_C_FLAGS=-m32 -DCMAKE_CXX_FLAGS=-m32 ..
open PhD2.xcodeproj
}}}

The last line opens the project in XCode.


== Creating the Makefiles on Linux ==
We suppose you have 
  * CMake
  * a compilation toolchain (eg. `gcc`, `ld`, `make`...)
  * installed [#Building_and_installing_wxWidgets  wxWidgets]
  * installed [#Installing_Indi_and_Nova Indi and Nova] library packages

{{{
cd $OPG_SRC
mkdir tmp
cd tmp
cmake ..
make -j 4
}}}

As for the other platforms, it is possible to specify another wxWidget distribution by providing the location of the installation prefix on the `cmake` command line:

{{{
cmake -DwxWidgets_PREFIX_DIRECTORY=$WXWIN ..
}}}

However if the wxWidget packages have been installed properly, the default `cmake` command should just run fine.




= Developing with `cmake` =

We provide here some tips for being able to develop with `cmake`. 

As mentioned earlier, `cmake` is a program that generates for you a Visual Studio solution, an XCode workspace or a bunch of Makefiles. 
One of the major benefit is that there is only one build configuration to maintain, contained in one or more text files.

== Avoid creating the `cmake` project along the sources ==
To keep the source tree clean from the files generated by the `cmake` step, it is a good habit to separate the /cmake binary tree/ from the sources
that are under version control. Also, putting `cmake` generated files under version control is discouraged, which means that Visual Studio solutions
or XCode workspaces should not be added to the repository (as they can be generated). 

== Avoid editing the generated solutions/workspaces/makefiles ==
The principal source for generating the build configuration lies inside the `cmake` configuration files (CMakeLists.txt, ...). This means that
any regeneration of the Visual Studio solutions or XCode workspace will be based on these `cmake` files, and any modification to those will be lost
during the regeneration.

== Regeneration of the Visual solutions / XCode workspaces ==
If the `cmake` files are modified, the Visual solution or XCode workspace need to be regenerated. In a solution/workspace, all targets depend on 
a `cmake` specific target called `ZERO_CHECK`. This target checks if the solution/workspace needs to be regenerated before continuing the build of the
desired target.

Most of the time, building the `ZERO_CHECK` target directly from the solution explorer will bring the `cmake` changes to the solution/workspace. 
Under Visual, each project of the solution that is modified should be unloaded and then reloaded into the solution: these changes are automatically detected by Visual, 
so there is no requirement for manual intervention. However, when the number of changed project is high, this unload/reload process can sometimes be time consuming.
To address that issue, it is often more efficient to close the solution, regenerate the `cmake` configuration from the command line directly, and open the solution back again.

Note that the changes on the `cmake` configuration may have very minimal impact on the changes on the projects, if written that way. 
To have minimal impacts on the project, 
  * avoid changing definitions or include paths that are seen by all targets. For instance, the following line
{{{
include_directories(${wxWidgets_INCLUDE_DIRS})
}}}
  has an incidence on all targets that are defined in the CMakeLists.txt and below by the `add_subdirectory` directive. Instead, once the 
  PhD2 target is defined, one can do the following:
{{{
target_include_directories(Phd2 PRIVATE ${wxWidgets_INCLUDE_DIRS})
}}}
  which makes the include of the wxWidgets path local to the PhD2 target. `PUBLIC` visibility (instead of `PRIVATE` as shown here) 
  propagates to the dependent targets. 
  * Same goes for definitions.
    
